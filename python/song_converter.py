import os
print("imported OS")
print()

#get the directory of this script
cwd = os.getcwd()
print("current working directory is " + cwd)

#navigate to the directory containing the original song data
originalSongDir = os.path.join(cwd, os.pardir, 'data', 'audio', 'songs_original')
print("the original song directory is " + originalSongDir)

#navigate to the directory containing the processed song data
processedSongDir = os.path.join(cwd, os.pardir, 'data', 'audio', 'songs_processed')
print("the processed song directory is " + processedSongDir)
gitignore = open(os.path.join(processedSongDir, '.gitignore'), "w")
gitignore.close()

originalSampleDir = os.path.join(cwd, os.pardir, 'data', 'audio', 'samples_processed')
print("the processed sample directory is " + originalSampleDir)

#open the audio_list file
audioListPath = os.path.join(cwd, os.pardir, 'source', 'audio', 'audio_list.c')
print("the global audio list file is " + audioListPath)
print()

#count how many files are in the raw sample folder
songList = os.listdir(originalSongDir)
print("There are " + str(len(songList)) + " files in songs_original.")
print()

#setup the global lists
processedSongList = []
originalSamplesList = []

#delete and recreate audio_list.c
if os.path.exists(audioListPath):
	os.remove(audioListPath)
audioList = open(audioListPath, "w")
audioList.write("//This file is automatically generated by [song_converter.py]. Do not edit manually.\n#include \"audio_engine_internal.h\"\n\n")

#delete every sample file
originalSampleList = os.listdir(originalSampleDir)
for currentOriginalSampleFile in originalSampleList:
	os.remove(os.path.join(originalSampleDir, currentOriginalSampleFile))
gitignore = open(os.path.join(originalSampleDir, '.gitignore'), "w")
gitignore.close()

for currentOriginalSongFile in songList:
	#create the path for this song and the processed result
	currentOriginalSongPath = os.path.join(originalSongDir, currentOriginalSongFile)
	currentSongFileName = "_" + (os.path.splitext(currentOriginalSongFile)[0]).replace(" ", "").replace("\0", "").replace(".", "") \
		.replace(",", "")
	currentProcessedSongPath = os.path.join(processedSongDir, currentSongFileName + ".c")
	currentProcessedSongFile = os.path.basename(currentProcessedSongPath)
		
	#check if this file is a valid IT file
	if (os.path.splitext(currentOriginalSongPath)[1]).lower() != ".it":
		#if this file is not an it file, move on to the next file
		print(currentOriginalSongFile + " is not a valid .IT file.")
		print()
		continue
		
	#open this IT file
	currentOriginalSong = open(currentOriginalSongPath, "rb")
	print("Now working on " + currentOriginalSongFile)
	print()
		
	#append this song to the list of all songs
	processedSongList.append(currentSongFileName)
		
	#check if this file already exists in the processed folder
	if os.path.exists(currentProcessedSongPath):
		os.remove(currentProcessedSongPath)
		
	currentProcessedSong = open(currentProcessedSongPath, "w")
	currentProcessedSong.write("#include \"audio_engine_internal.h\"\n\n")
	print("writing to file " + currentProcessedSongFile)
	print() 
		
	#read the entire file
	currentSongRawData = currentOriginalSong.read()
	print("(" + str(len(currentSongRawData)) + "/" + str(len(currentSongRawData)) + ") bytes read successfully. Extracting data.")
	print()
		
	#extract the global data from the song header
	currentSongName = currentSongRawData[4:30]
	print("Song Name: " + currentSongName.decode("ascii"))
	currentSongOrdersNum = ((currentSongRawData[0x21] << 8) | currentSongRawData[0x20]) - 1
	currentSongInstrumentsNum = (currentSongRawData[0x23] << 8) | currentSongRawData[0x22]
	currentSongSamplesNum = (currentSongRawData[0x25] << 8) | currentSongRawData[0x24]
	currentSongPatternsNum = (currentSongRawData[0x27] << 8) | currentSongRawData[0x26]
	currentSongInitGlobalVol = currentSongRawData[0x30]
	currentSongInitTickSpeed = currentSongRawData[0x32]
	currentSongInitTempo = currentSongRawData[0x33]
	currentSongInitChannelPan = currentSongRawData[0x40:0x4C]
	currentSongInitChannelVol = currentSongRawData[0x80:0x8C]
		
	#extract the sequenced pattern orders
	currentSongOrders = [] 
	ordersIndex = 0xc0
	for i in range(currentSongOrdersNum):
		currentSongOrders.append(currentSongRawData[ordersIndex + i])
		
	#extract the pointers to the instrument data
	currentSongInstruments = []
	instrumentsIndex = 0xc0 + currentSongOrdersNum + 1
	for i in range(currentSongInstrumentsNum):
		currentSongInstruments.append(currentSongRawData[instrumentsIndex + (i * 4)] | (currentSongRawData[instrumentsIndex + (i * 4) + 1] << 8) | \
		(currentSongRawData[instrumentsIndex + (i * 4) + 2] << 16) + (currentSongRawData[instrumentsIndex + (i * 4) + 3] << 24))
		
	#extract the pointers to the sample data
	currentSongSamples = []
	samplesIndex = instrumentsIndex + (currentSongInstrumentsNum * 4)
	for i in range(currentSongSamplesNum):
		currentSongSamples.append(currentSongRawData[samplesIndex + (i * 4)] | (currentSongRawData[samplesIndex + (i * 4) + 1] << 8) | \
		(currentSongRawData[samplesIndex + (i * 4) + 2] << 16) + (currentSongRawData[samplesIndex + (i * 4) + 3] << 24))
		
	#extract the pointers to the pattern data
	currentSongPatterns = []
	patternsIndex = samplesIndex + (currentSongSamplesNum * 4)
	for i in range(currentSongPatternsNum):
		currentSongPatterns.append(currentSongRawData[patternsIndex + (i * 4)] | (currentSongRawData[patternsIndex + (i * 4) + 1] << 8) | \
		(currentSongRawData[patternsIndex + (i * 4) + 2] << 16) + (currentSongRawData[patternsIndex + (i * 4) + 3] << 24))
		
	#write the orders for this song
	currentProcessedSong.write("cu8 " + currentSongFileName + "Orders[] = {")
	for i in range(currentSongOrdersNum):
		if (i % 32) == 0:
			currentProcessedSong.write("\n\t")
		if i != (currentSongOrdersNum - 1):
			currentProcessedSong.write(hex(currentSongOrders[i]) + ", ") 
		else:
			currentProcessedSong.write(hex(currentSongOrders[i]) + "\n};\n\n") 
	print("(" + str(currentSongOrdersNum) + "/" + str(currentSongOrdersNum) + ") sequenced patterns successfully formatted.")
		
	#handle the instruments
	currentProcessedSong.write("InstrumentData " + currentSongFileName + "Instruments[] = {\n")
	keyboardSample = []
	volEnvalopeNodes = []
	panEnvalopeNodes = []
	pitEnvalopeNodes = []
	for i in range(currentSongInstrumentsNum):
		#extract the data from each instrument
		currentInstrumentIndex = currentSongInstruments[i]
		fadeOut = currentSongRawData[currentInstrumentIndex + 0x14] | (currentSongRawData[currentInstrumentIndex + 0x15] << 8)
		pitPanSeparation = currentSongRawData[currentInstrumentIndex + 0x16]
		pitPanCenter = currentSongRawData[currentInstrumentIndex + 0x17]
		globalVolume = currentSongRawData[currentInstrumentIndex + 0x18]
		defaultPan = currentSongRawData[currentInstrumentIndex + 0x19]
		randomVolVariation = currentSongRawData[currentInstrumentIndex + 0x1a]
		randomPanVariation = currentSongRawData[currentInstrumentIndex + 0x1b]
		currentInstrumentIndex += 0x40
		keyboardSample.clear()
		for j in range(120):
			keyboardSample.append(currentSongRawData[currentInstrumentIndex + (j*2) + 1] - 1)
		currentInstrumentIndex += 0xf0
		volEnvalopeFlag = currentSongRawData[currentInstrumentIndex]
		volEnvalopeNodeCount = currentSongRawData[currentInstrumentIndex + 0x1]
		volEnvalopeLoopBegin = currentSongRawData[currentInstrumentIndex + 0x2]
		volEnvalopeLoopEnd = currentSongRawData[currentInstrumentIndex + 0x3]
		volEnvalopeSustainBegin = currentSongRawData[currentInstrumentIndex + 0x4]
		volEnvalopeSustainEnd = currentSongRawData[currentInstrumentIndex + 0x5]
		currentInstrumentIndex += 0x6
		volEnvalopeNodes.clear()
		for j in range(25):
			volEnvalopeNodes.append(currentSongRawData[currentInstrumentIndex + (j * 3)])
			volEnvalopeNodes.append(currentSongRawData[currentInstrumentIndex + (j * 3) + 1] | (currentSongRawData[currentInstrumentIndex + (j * 3) + 2] << 8))
		currentInstrumentIndex += 0x4c
		panEnvalopeFlag = currentSongRawData[currentInstrumentIndex]
		panEnvalopeNodeCount = currentSongRawData[currentInstrumentIndex + 0x1]
		panEnvalopeLoopBegin = currentSongRawData[currentInstrumentIndex + 0x2]
		panEnvalopeLoopEnd = currentSongRawData[currentInstrumentIndex + 0x3]
		panEnvalopeSustainBegin = currentSongRawData[currentInstrumentIndex + 0x4]
		panEnvalopeSustainEnd = currentSongRawData[currentInstrumentIndex + 0x5]
		currentInstrumentIndex += 0x6
		panEnvalopeNodes.clear()
		for j in range(25):
			panEnvalopeNodes.append(currentSongRawData[currentInstrumentIndex + (j * 3)])
			panEnvalopeNodes.append(currentSongRawData[currentInstrumentIndex + (j * 3) + 1] | (currentSongRawData[currentInstrumentIndex + (j * 3) + 2] << 8))
		currentInstrumentIndex += 0x4c
		pitEnvalopeFlag = currentSongRawData[currentInstrumentIndex]
		pitEnvalopeNodeCount = currentSongRawData[currentInstrumentIndex + 0x1]
		pitEnvalopeLoopBegin = currentSongRawData[currentInstrumentIndex + 0x2]
		pitEnvalopeLoopEnd = currentSongRawData[currentInstrumentIndex + 0x3]
		pitEnvalopeSustainBegin = currentSongRawData[currentInstrumentIndex + 0x4]
		pitEnvalopeSustainEnd = currentSongRawData[currentInstrumentIndex + 0x5]
		currentInstrumentIndex += 0x6
		pitEnvalopeNodes.clear()
		for j in range(25):
			pitEnvalopeNodes.append(currentSongRawData[currentInstrumentIndex + (j * 3)])
			pitEnvalopeNodes.append(currentSongRawData[currentInstrumentIndex + (j * 3) + 1] | (currentSongRawData[currentInstrumentIndex + (j * 3) + 2] << 8))
			
		#write this instrument's data structure into the file
		currentProcessedSong.write("\t{.fadeOut = " + hex(fadeOut) + ", .pitPanSeparation = " + \
		hex(pitPanSeparation) + ", .pitPanCenter = " + hex(pitPanCenter) + ", .globalVolume = " + \
		hex(globalVolume) + ", .defaultPan = " + hex(defaultPan) + ", .randomVolVariation = " + \
		hex(randomVolVariation) + ", .randomPanVariation = " + hex(randomPanVariation) + ", .keyboardSample = {")
		for j in range(120):
			if (j % 30) == 0:
				currentProcessedSong.write("\n\t")
			if j != 119:
				currentProcessedSong.write(hex(keyboardSample[j]) + ", ")
			else:
				currentProcessedSong.write(hex(keyboardSample[j]) + "},\n\t")
		currentProcessedSong.write(".volEnvalope = {.flags = " + hex(volEnvalopeFlag) + ", .nodeCount = " + \
		hex(volEnvalopeNodeCount) + ", .loopBegin = " + hex(volEnvalopeLoopBegin) + ", .loopEnd = " + \
		hex(volEnvalopeLoopEnd) + ", .sustainBegin = " + hex(volEnvalopeSustainBegin) + ", .sustainEnd = " + \
		hex(volEnvalopeSustainEnd))
		if (volEnvalopeNodeCount == 0):
			currentProcessedSong.write("}}")
		else:
			currentProcessedSong.write(",\n\t.envalopeNodes = {")
			for j in range(volEnvalopeNodeCount): 
				if ((j+5) % 10) == 0:
					currentProcessedSong.write("\n\t")
				if j != (volEnvalopeNodeCount - 1):
					currentProcessedSong.write("{" + hex(volEnvalopeNodes[j*2]) + ", " + hex(volEnvalopeNodes[(j*2) + 1]) + "}, ")
				else:
					currentProcessedSong.write("{" + hex(volEnvalopeNodes[j*2]) + ", " + hex(volEnvalopeNodes[(j*2) + 1]) + "}}},\n\t")
		currentProcessedSong.write(".panEnvalope = {.flags = " + hex(panEnvalopeFlag) + ", .nodeCount = " + \
		hex(panEnvalopeNodeCount) + ", .loopBegin = " + hex(panEnvalopeLoopBegin) + ", .loopEnd = " + \
		hex(panEnvalopeLoopEnd) + ", .sustainBegin = " + hex(panEnvalopeSustainBegin) + ", .sustainEnd = " + \
		hex(panEnvalopeSustainEnd))
		if (panEnvalopeNodeCount == 0):
			currentProcessedSong.write("}}")
		else:
			currentProcessedSong.write(",\n\t.envalopeNodes = {")
			for j in range(panEnvalopeNodeCount): 
				if ((j+5) % 10) == 0:
					currentProcessedSong.write("\n\t")
				if j != (panEnvalopeNodeCount - 1):
					currentProcessedSong.write("{" + hex(panEnvalopeNodes[j*2]) + ", " + hex(panEnvalopeNodes[(j*2) + 1]) + "}, ")
				else:
					currentProcessedSong.write("{" + hex(panEnvalopeNodes[j*2]) + ", " + hex(panEnvalopeNodes[(j*2) + 1]) + "}}},\n\t")
		currentProcessedSong.write(".pitchEnvalope = {.flags = " + hex(pitEnvalopeFlag) + ", .nodeCount = " + \
		hex(pitEnvalopeNodeCount) + ", .loopBegin = " + hex(pitEnvalopeLoopBegin) + ", .loopEnd = " + \
		hex(pitEnvalopeLoopEnd) + ", .sustainBegin = " + hex(pitEnvalopeSustainBegin) + ", .sustainEnd = " + \
		hex(pitEnvalopeSustainEnd))
		if (pitEnvalopeNodeCount == 0):
			currentProcessedSong.write("}}")
		else:
			currentProcessedSong.write(",\n\t.envalopeNodes = {")
			for j in range(pitEnvalopeNodeCount): 
				if ((j+5) % 10) == 0:
					currentProcessedSong.write("\n\t")
				if j != (pitEnvalopeNodeCount - 1):
					currentProcessedSong.write("{" + hex(pitEnvalopeNodes[j*2]) + ", " + hex(pitEnvalopeNodes[(j*2) + 1]) + "}, ")
				else:
					currentProcessedSong.write("{" + hex(pitEnvalopeNodes[j*2]) + ", " + hex(pitEnvalopeNodes[(j*2) + 1]) + "}}}}")
		if i != (currentSongInstrumentsNum - 1):
			currentProcessedSong.write(",")
		else:
			currentProcessedSong.write("\n};")
		currentProcessedSong.write("\n\n")
	print("(" + str(currentSongInstrumentsNum) + "/" + str(currentSongInstrumentsNum) + ") instruments successfully formatted.")
		
	#extract and write each pattern's raw data
	for i in range(currentSongPatternsNum):
		currentProcessedSong.write("cu8 " + currentSongFileName + "Pattern" + str(i) + "[] = {")
		currentPatternIndex = currentSongPatterns[i]
		#check if this is an empty pattern
		if(currentPatternIndex == 0):
			currentProcessedSong.write("\n};\n\n")
			continue
		currentPatternLength = currentSongRawData[currentPatternIndex] | (currentSongRawData[currentPatternIndex + 1] << 8)
		currentPatternIndex += 8
		for j in range(currentPatternLength):
			if (j % 24) == 0:
				currentProcessedSong.write("\n\t")
			if j != (currentPatternLength - 1):
				currentProcessedSong.write(hex(currentSongRawData[currentPatternIndex + j]) + ", ")
			else:
				currentProcessedSong.write(hex(currentSongRawData[currentPatternIndex + j]) + "\n};\n\n")
		
	#write the data structure linking all of the patterns together
	currentProcessedSong.write("PatternData " + currentSongFileName + "Patterns[] = {\n\t")
	for i in range(currentSongPatternsNum):
		currentPatternIndex = currentSongPatterns[i]
		currentPatternRowsNum = currentSongRawData[currentPatternIndex + 2]
		currentProcessedSong.write("{.rowsNum = " + hex(currentPatternRowsNum) + ", .packedPatternData = " + \
		currentSongFileName + "Pattern" + str(i))
		if i != (currentSongPatternsNum - 1):
			currentProcessedSong.write("},\n\t")
		else:
			currentProcessedSong.write("}\n};\n\n")
	print("(" + str(currentSongPatternsNum) + "/" + str(currentSongPatternsNum) + ") patterns successfully formatted.")
		
	#extract the sample data
	currentProcessedSong.write("cu16 " + currentSongFileName + "Samples[] = {\n\t")
	failedSamples = 0
	currentSampleRawData = []
	for i in range(currentSongSamplesNum):
		currentSampleIndex = currentSongSamples[i]
		currentOriginalSampleNameRaw = currentSongRawData[(currentSampleIndex + 0x14):(currentSampleIndex + 0x2e)]
		currentOriginalSampleName = "_" + (currentOriginalSampleNameRaw.decode("ascii").replace(" ", "").replace("\0", "").replace(".", "") \
		.replace(",", "").replace("/", "").replace("\\", "").replace("-", "")).replace("(", "").replace(")", "").replace("!", "") \
		.replace(":", "").replace("@", "").replace("'", "").replace("#", "")
		currentOriginalSamplePath = os.path.join(originalSampleDir, currentOriginalSampleName + ".s")
		currentSampleFlags = currentSongRawData[currentSampleIndex + 0x12]
		currentSampleFormatFlags = currentSongRawData[currentSampleIndex + 0x2e]
		
		#if the sample is blank
		if currentOriginalSampleName == "_":
			#add this sample to the song's sample list
			currentProcessedSong.write("0xffff, ")
			print("\t(" + str(i + 1) + "/" + str(currentSongSamplesNum) + ") Sample: " + \
			currentOriginalSampleName + " is a blank sample, unnamed samples are not permitted.")
			failedSamples += 1
			continue
		
		#if this is a psg sample, 
		if currentOriginalSampleName[0:4] == "_PSG":
			#add this sample to the song's sample list
			currentProcessedSong.write("0xffff, ")
			print("\t(" + str(i + 1) + "/" + str(currentSongSamplesNum) + ") Sample: " + \
			currentOriginalSampleName + " is a PSG Sample, ignoring.")
			continue
			
		#check if this sample already exists, another song already processed this sample. 
		if os.path.exists(currentOriginalSamplePath):
			#just add it to the pointers list, no other processing needed
			print("\t(" + str(i + 1) + "/" + str(currentSongSamplesNum) + ") Sample: " + \
			currentOriginalSampleName + " already exists. Linking to the existing sample.")
			index = originalSamplesList.index(currentOriginalSampleName)
			currentProcessedSong.write(hex(index) + ", ")
			continue
			
		#check if this sample is in a supported format
		if(currentSampleFlags & 0xC) or (currentSampleFormatFlags & 0x3c):
			print("\t(" + str(i + 1) + "/" + str(currentSongSamplesNum) + ") Sample: " + \
			currentOriginalSampleName + " is in an unsupported format. Skipping.")
			failedSamples += 1
			continue
			
		#extracting the sample from the IT file.
		currentSampleGlobalVolume = currentSongRawData[currentSampleIndex + 0x11]
		currentSampleDefaultVolume = currentSongRawData[currentSampleIndex + 0x13]
		currentSampleDefaultPan = currentSongRawData[currentSampleIndex + 0x2f]
		currentSampleLength = currentSongRawData[currentSampleIndex + 0x30] | (currentSongRawData[currentSampleIndex + 0x31] << 8) | \
		(currentSongRawData[currentSampleIndex + 0x32] << 16) | (currentSongRawData[currentSampleIndex + 0x33] << 24)
		currentSampleMiddleCPitch = currentSongRawData[currentSampleIndex + 0x3c] | (currentSongRawData[currentSampleIndex + 0x3d] << 8) | \
		(currentSongRawData[currentSampleIndex + 0x3e] << 16) | (currentSongRawData[currentSampleIndex + 0x3f] << 24)
		currentSampleDataIndex = currentSongRawData[currentSampleIndex + 0x48] | (currentSongRawData[currentSampleIndex + 0x49] << 8) | \
		(currentSongRawData[currentSampleIndex + 0x4a] << 16) | (currentSongRawData[currentSampleIndex + 0x4b] << 24)
		currentSampleVibratoSpeed = currentSongRawData[currentSampleIndex + 0x4c]
		currentSampleVibratoDepth = currentSongRawData[currentSampleIndex + 0x4d]
		currentSampleVibratoSweep = currentSongRawData[currentSampleIndex + 0x4e]
		currentSampleVibratoWave = currentSongRawData[currentSampleIndex + 0x4f]
			
		#create a raw file for this sample
		currentOriginalSample = open(currentOriginalSamplePath, "w")
		currentSampleLoopStart = currentSongRawData[currentSampleIndex + 0x34] | (currentSongRawData[currentSampleIndex + 0x35] << 8) | \
		(currentSongRawData[currentSampleIndex + 0x36] << 16) | (currentSongRawData[currentSampleIndex + 0x37] << 24)
		currentSampleLoopEnd = currentSongRawData[currentSampleIndex + 0x38] | (currentSongRawData[currentSampleIndex + 0x39] << 8) | \
		(currentSongRawData[currentSampleIndex + 0x3a] << 16) | (currentSongRawData[currentSampleIndex + 0x3b] << 24)
		currentSampleSustainLoopStart = currentSongRawData[currentSampleIndex + 0x40] | (currentSongRawData[currentSampleIndex + 0x41] << 8) | \
		(currentSongRawData[currentSampleIndex + 0x42] << 16) | (currentSongRawData[currentSampleIndex + 0x43] << 24)
		currentSampleSustainLoopEnd = currentSongRawData[currentSampleIndex + 0x44] | (currentSongRawData[currentSampleIndex + 0x45] << 8) | \
		(currentSongRawData[currentSampleIndex + 0x46] << 16) | (currentSongRawData[currentSampleIndex + 0x47] << 24)
		currentSampleLoopPong = currentSampleFlags & 0x40
		sampleIndex = 0;
		currentSampleRawData.clear()
		
		for each in range(currentSampleLength):
				
			#if 8 bits
			if(currentSampleFlags & 0x2) == 0:
				sampleData = currentSongRawData[currentSampleDataIndex + sampleIndex]
			#if 16 bits little endian
			elif(currentSampleFormatFlags & 0x2) == 0:
				sampleData = currentSongRawData[currentSampleDataIndex + (sampleIndex * 2) + 1]
			#if 16 bits big endian
			else:
				sampleData = currentSongRawData[currentSampleDataIndex + (sampleIndex * 2)]
			#if samples are signed
			if(currentSampleFormatFlags & 0x1) == 1:
				if(sampleData >= 128):
					sampleData -= 128
				else:
					sampleData += 128
				
			sampleIndex += 1
			currentSampleRawData.append(sampleData)
				
		#write the data into the sample file
		currentOriginalSample.write(".section\t.rodata\n.global\t" + currentOriginalSampleName + "_data\n.align 2\n" + \
		currentOriginalSampleName + "_data:")
		for j in range(len(currentSampleRawData)):	
			if j == (len(currentSampleRawData) - 1):
				currentOriginalSample.write(", " + hex(currentSampleRawData[j]) + ", 0x80\n")
			elif(j % 32) == 0:
				delta = currentSampleRawData[j + 1] - currentSampleRawData[j]
				delta += 1
				delta >>= 1
				delta += 128
				if delta == 0x100:
					delta = 0xff
				currentOriginalSample.write("\n.byte\t" + hex(currentSampleRawData[j]))
				currentOriginalSample.write(", " + hex(delta))
			else:
				delta = currentSampleRawData[j + 1] - currentSampleRawData[j]
				delta += 1
				delta >>= 1
				delta += 128
				if delta == 0x100:
					delta = 0xff
				currentOriginalSample.write(", " + hex(currentSampleRawData[j]))
				currentOriginalSample.write(", " + hex(delta))
			
		#write the data into the audio list
		audioList.write("extern cu8 " + currentOriginalSampleName + "_data[];\nAudioSample " + \
		currentOriginalSampleName + " = {\n\t.sampleStart = " + currentOriginalSampleName + "_data, .sampleLength = " + str(currentSampleLength) + ", .loopEnd = " + \
		str(currentSampleLoopEnd) + ", .loopStart = " + str(currentSampleLoopStart) + ", .sustainLoopEnd = " + str(currentSampleSustainLoopStart) + \
		", .sustainLoopStart = " + str(currentSampleSustainLoopEnd) + ", .middleCPitch = " + str(currentSampleMiddleCPitch) + ",\n\t.sampleType = " + \
		str(currentSampleFlags >> 4) + ", .globalVolume = " + str(currentSampleGlobalVolume) + ", .defaultVolume = " + \
		str(currentSampleDefaultVolume) + ", .defaultPan = " + str(currentSampleDefaultPan) + ", .vibratoSpeed = " + \
		str(currentSampleVibratoSpeed) + ", .vibratoDepth = " + str(currentSampleVibratoDepth) + ", .vibratoWave = " + \
		str(currentSampleVibratoWave) + ", .vibratoSweep = " + str(currentSampleVibratoSweep) + "\n};\n\n")
		
		#add this sample to the sample list
		originalSamplesList.append(currentOriginalSampleName)
		currentProcessedSong.write(hex(len(originalSamplesList) - 1) + ", ")
		
		print("\t(" + str(i + 1) + "/" + str(currentSongSamplesNum) + ") Sample: " + currentOriginalSampleName + " successfully formatted.")
		currentOriginalSample.close()
		
	currentProcessedSong.write("\n};\n\n")
	print("(" + str(currentSongSamplesNum - failedSamples) + "/" + str(currentSongSamplesNum) + ") Samples successfully formatted")
		
	#write the SongData struct for this song
	currentProcessedSong.write("SongData " + currentSongFileName + "Song = {\n\t.orders = " + \
	currentSongFileName + "Orders, .instruments = " + currentSongFileName + "Instruments, .samples = " + \
	currentSongFileName + "Samples, .patterns = " + currentSongFileName + "Patterns, .songName = \"" + \
	(currentSongName.decode("ascii")).strip("\0") + "\",\n\t.ordersNum = " + hex(currentSongOrdersNum) + ", .instrumentsNum = " + \
	hex(currentSongInstrumentsNum) + ", .samplesNum = " + hex(currentSongSamplesNum) + ", .patternsNum = " + \
	hex(currentSongPatternsNum) + ", .initGlobalVol = " + hex(currentSongInitGlobalVol) + ", .initTickSpeed = " + \
	hex(currentSongInitTickSpeed) + ", .initTempo = " + hex(currentSongInitTempo) + ",\n\t.initChannelVol = {")
	i = 0
	for currentChannelData in currentSongInitChannelVol:
		i += 1
		if i != len(currentSongInitChannelVol):
			currentProcessedSong.write(hex(currentChannelData) + ", ")
		else:
			currentProcessedSong.write(hex(currentChannelData))
	currentProcessedSong.write("}, .initChannelPan = {")
	i = 0
	for currentChannelData in currentSongInitChannelPan:
		i += 1
		if i != len(currentSongInitChannelPan):
			currentProcessedSong.write(hex(currentChannelData) + ", ")
		else:
			currentProcessedSong.write(hex(currentChannelData))
	currentProcessedSong.write("}\n\t};\n")
	
	if (failedSamples == 0):
		print("Song: " + (currentSongName.decode("ascii").strip("\0")) + " successfully formatted\n")
	else:
		print("Song: " + (currentSongName.decode("ascii").strip("\0")) + " completed with " + str(failedSamples) + " failed samples\n")
		
	#close the open files
	currentOriginalSong.close()
	currentProcessedSong.close()
	
#write the list of every sample to the audio_list file
audioList.write("AudioSample *sampleList[] = {\n\t")
for i in range(len(originalSamplesList)):
	if i != len(originalSamplesList) - 1:
		audioList.write("&" + originalSamplesList[i] + ", ")
	else:
		audioList.write("&" + originalSamplesList[i] + "\n};\n\n")

audioList.write("cu16 numSamples = " + str(len(originalSamplesList)) + ";\n\n")

#write the list of every song to the audio_list file
for i in range(len(processedSongList)):
	audioList.write("extern SongData " + processedSongList[i] + "Song;\n")
audioList.write("SongData *songList[] = {\n\t")
for i in range(len(processedSongList)):
	if i != len(processedSongList) - 1:
		audioList.write("&" + processedSongList[i] + "Song, ")
	else:
		audioList.write("&" + processedSongList[i] + "Song\n};\n\n")
	
audioList.write("cu16 numSongs = " + str(len(processedSongList)) + ";\n\n")

audioList.close()
print("All songs processed. Press enter to close.")
input()

